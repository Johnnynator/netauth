// This is the master proto for NetAuth.  It contains the RPC
// definitions needed to auth a user as well as to change the state of
// a user's account.

syntax = "proto2";

// Capabilities permit the holder to perform special actions within
// NetAuth.  This allows the holder to do things related to management
// of the server without needing to use the GLOBAL_ROOT bootstrap
// user.
enum Capability {
  GLOBAL_ROOT = 0;
  CREATE_ENTITY = 1;
  DESTORY_ENTITY = 2;
  MODIFY_ENTITY_META = 3;
  CHANGE_ENTITY_SECRET = 4;
  CREATE_GROUP = 5;
  DESTROY_GROUP = 6;
  MODIFY_GROUP_META = 7;
  MODIFY_GROUP_MEMBERS = 8;
}

service NetAuth {
  // AuthEntity takes in an entity with an ID and secret set and will
  // attempt to validate that they are who they say they are.
  rpc AuthEntity(NetAuthRequest) returns (SimpleResult) {}

  // EntityInfo takes in an entity and will try to return as much info
  // as is known about it.
  rpc EntityInfo(NetAuthRequest) returns (Entity) {}

  // It is desireable to ping the server for status and health
  rpc Ping(PingRequest) returns (PingResponse) {}

  // Obviously we'll need to be able to add entities to the server
  rpc NewEntity(ModEntityRequest) returns (SimpleResult) {}

  // Entities may need to be removed.
  rpc RemoveEntity(ModEntityRequest) returns (SimpleResult) {}

  // Secrets should be changed periodically
  rpc ChangeSecret(ModEntityRequest) returns (SimpleResult) {}

  // Getting a member list from a group is the beginning of the group
  // functionality.
  rpc ListGroupMembers(GroupMemberRequest) returns (EntityList) {}

  // The minimal directory functions require modifying the entity
  // information to update values.
  rpc ModifyEntityMeta(ModEntityRequest) returns (SimpleResult) {}

  // NewGroup allows us to create arbitrary groups.
  rpc NewGroup(ModGroupRequest) returns (SimpleResult) {}

  // DeleteGroup deletes a group.
  rpc DeleteGroup(ModGroupRequest) returns (SimpleResult) {}

  // ModifyGroupMeta allows limited modifications of group metadata,
  // largely the displayName
  rpc ModifyGroupMeta(ModGroupRequest) returns (SimpleResult) {}

  // ListGroups provides a list of group names.
  rpc ListGroups(GroupListRequest) returns (GroupList) {}

  // Group membership is modified either on entities or on groups.
  rpc AddEntityToGroup(ModGroupDirectMembershipRequest) returns (SimpleResult) {}
  rpc RemoveEntityFromGroup(ModGroupDirectMembershipRequest) returns (SimpleResult) {}
}

// An AuthRequest includes an Entity and some information to identify
// the system that is making the request.
message NetAuthRequest {
  // The Entity is obviously the most important part of the
  // AuthRequest which is the thing we want to authenticate.
  required Entity entity = 1;

  // Additionally we want to know the client ID that is making the
  // authentication request.  This is set by the client and must not
  // be used for any security purposes.  Its intention is to be used
  // for logging and statistics to find clients with problems.
  optional string clientID = 2;

  // It would also be nice to know what this authentication is for,
  // this is again set by the client and shouldn't be used for
  // security purposes.  The idea here is that if there are multiple
  // systems all making requests with the same clientID this will
  // differentiate them.
  optional string serviceID = 3;
}

// A ModEntityRequest takes an entity to authorize and an entity to
// act upon.  These may be the same entity for changes being applied
// by an entity to itself.
message ModEntityRequest {
  // The request must always have an entity, the second entity may not
  // be set in which case the first entity will be acted upon.
  required Entity entity = 1;

  // This is the entity to act on, it may be set or it may not be.
  optional Entity modEntity = 2;
}

message ModGroupDirectMembershipRequest {
  // The change is authorized by an entity, not necessarily the one that's being changed.
  required Entity entity = 1;
  optional string modEntity = 2;

  // The group that is being added or removed is taken as a group name
  required string GroupName = 3;

  optional string clientID = 4;
  optional string serviceID = 5;
}

// An entity may be a person or a machine actor that wishes to act as
// some identity.  To do so they will need to transmit an ID and a
// secret which will be used to verify that they are who they say they
// are.
message Entity {
  // The entity may be identified by a string.  This is most common
  // for the initial authentication case where a people-entity has
  // typed a name in and now wishes to be authenticated.
  optional string ID = 1;

  // An entity might also be identified by a unique ID number.  This
  // case is most common when some program wishes to get information
  // about an entity.
  optional int32 uidNumber = 2;

  // The entity may have a secret which they will use to authenticate
  // themselves.
  optional string secret = 3;

  // For requests that update the meta information this must be
  // attatched to the entity itself.  This also allows the in-memory
  // format to be defined by this proto.
  optional EntityMeta meta = 4;
}

// A SimpleResult can be returned from most services and explains
// whether or not the service completed successfully or not, and an
// optional message that may explain in more detail.
message SimpleResult {
  // Required is forever, but a SimpleResult without a success state
  // doesn't mean much.  This field must be present in all replies.
  required bool success = 1 [default = false];

  // In the failure case a message may be provided detailing the
  // failure.  This message must not contain secure information and
  // there must be an expectation that anything placed in this field
  // will be shown directly to a person or written to a log.
  optional string msg = 2;
}

// While machine entities may belong to only one group, people
// entities often belong to many groups at once.  This message
// structures the reply for the additional groups.
message Group {
  // A group name must satisfy the requirements of the UNIX group
  // naming conventions.  This should be one word, lower case, with no
  // spaces and cannot begin with a number.
  optional string name = 1;

  // Since the name has strict naming requirements, its nice to have a
  // displayName for the group which has a more friendly display.
  // Instead of trying to reason out what naacct means, its much nicer
  // to just know that its "Accounting team - North America"
  optional string displayName = 2;

  // On *nix systems the group should also have a number.  This number
  // should be the same across all systems since it may be used for
  // internal matching of users.
  optional int32 gidNumber = 3;

  // Groups may have capabilities that are conferred to members of the
  // group on a membership basis.  This is the preferred way of
  // granting capabilities to an entity since it means that when an
  // entity is removed from the group they lose the capabilities that
  // were granted from it.
  repeated Capability capabilities = 4;
}

message ModGroupRequest {
  // The entity that's authorizing this change.
  required Entity entity = 1;

  // The group that's being modified.
  required Group group = 2;

  // The ID of the client requesting this change
  optional string clientID = 3;

  // The serviceID on the client requesting this change.
  optional string serviceID = 4;
}

message GroupMemberRequest {
  // The group for which info is being requested.
  optional Group group = 1;

  // The ID of the client requesting the information.
  optional string clientID = 2;

  // The serviceID on the client requesting the information.
  optional string serviceID = 3;
}

message GroupListRequest{}

message GroupList {
  repeated Group groups = 1;
}

message EntityMeta {
  // The primary group ID for the entity.  On most UNIX systems this
  // will map to a group with the same string representation as the
  // Entity, but it is not uncommon for people-entities in a network
  // environment to not have a personal primary group and instead
  // belong to an organization wide primary group.
  optional Group pgid = 1;

  // This is an arbitrary field used to store things like the user's
  // real name.  It is here for consistency, but the name displayed by
  // the user should really be stored in displayName, with the actual
  // name stored in legalName (this facilitates a user to have an
  // arbitrary name displayed if this is permitted by local policy).
  optional string GECOS = 2;

  // This stores the legal name (if used) that owns this security
  // entity.  This primarily here for places where knowing the single
  // owning entity is a requirement for compliance reasons.
  optional string legalName = 3;

  // This field is for the display value of the legalName.  This lets
  // the displayed value fluctuate with no connection to the actual
  // identity of the owning entity.
  optional string displayName = 4;

  // Given that the entity identity and auth are provided by the
  // network, its not unlikely that the home directory for the entity
  // is as well.  This string contains the fully qualified path to the
  // home directory.
  optional string homedir = 5;

  // This string is the canonical 'user command interpreter' specified
  // in the passwd file.  This value provided by this field must be
  // safe to use on all target systems as setting this to something
  // that doesn't exist on the targets will cause the login program to
  // abort when setting up the environment.
  optional string shell = 6;

  // This is for the graphical shell, primarily for when the entity is
  // a person (though machine entities might also need to have a
  // graphical shell set).  This provides a handy place to store it,
  // but unfortunately a seperate mechanism is needed to get this into
  // the systems that actually setup the graphical environment.
  optional string graphicalShell = 7;

  // Person entities may have a physical badge which gets them access
  // to things, and machine entities may have an asset tag which is
  // nice to keep track of.  This is a string rather than a number
  // because the badge "number" might actually be a UUID or something
  // that is not otherwise a pure number.
  optional string badgeNumber = 8;

  // Entities may be direct members of groups
  repeated string groups = 9;

  // Entities may have capabilities that provide special actions to
  // the holder within NetAuth.
  repeated Capability capabilities = 10;
}

// GroupMemberList is returned when a query generates a list of
// entities.
message EntityList {
  repeated Entity members = 1;
}

// The PingRequest is used to ask the server to return its health
// status to the requestor.
message PingRequest {
  optional string clientID = 1;
}

// The PingReply is used to tell the client if this server is healthy
// and ready to serve.
message PingResponse {
  // The server will reply healthy=True if it is ready to serve.
  optional bool healthy = 1;

  // Optionally the server may have a message if it is not healthy.
  optional string msg = 2;
}
